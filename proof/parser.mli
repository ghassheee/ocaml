type token =
  | BOOL of (Support.info)
  | LAMBDA of (Support.info)
  | IF of (Support.info)
  | THEN of (Support.info)
  | ELSE of (Support.info)
  | TRUE of (Support.info)
  | FALSE of (Support.info)
  | SUCC of (Support.info)
  | PRED of (Support.info)
  | ISZERO of (Support.info)
  | UCID of (string  Support.withinfo)
  | LCID of (string  Support.withinfo)
  | INTV of (int     Support.withinfo)
  | FLOATV of (float   Support.withinfo)
  | STRINGV of (string  Support.withinfo)
  | APOSTROPHE of (Support.info)
  | DQUOTE of (Support.info)
  | ARROW of (Support.info)
  | BANG of (Support.info)
  | BARGT of (Support.info)
  | BARRCURLY of (Support.info)
  | BARRSQUARE of (Support.info)
  | COLON of (Support.info)
  | COLONCOLON of (Support.info)
  | COLONEQ of (Support.info)
  | COLONHASH of (Support.info)
  | COMMA of (Support.info)
  | DARROW of (Support.info)
  | DDARROW of (Support.info)
  | DOT of (Support.info)
  | EOF of (Support.info)
  | EQ of (Support.info)
  | EQEQ of (Support.info)
  | EXISTS of (Support.info)
  | GT of (Support.info)
  | HASH of (Support.info)
  | LCURLY of (Support.info)
  | LCURLYBAR of (Support.info)
  | LEFTARROW of (Support.info)
  | LPAREN of (Support.info)
  | LSQUARE of (Support.info)
  | LSQUAREBAR of (Support.info)
  | LT of (Support.info)
  | RCURLY of (Support.info)
  | RPAREN of (Support.info)
  | RSQUARE of (Support.info)
  | SEMI of (Support.info)
  | SLASH of (Support.info)
  | STAR of (Support.info)
  | TRIANGLE of (Support.info)
  | USCORE of (Support.info)
  | VBAR of (Support.info)
  | NEWLINE of (Support.info)
  | DOUBLESEMI of (Support.info)
  | HOGE of (Support.info)

val toplevel :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Syntax.context -> (Syntax.command list * Syntax.context)
val input :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Syntax.context -> (Syntax.command list * Syntax.context)
