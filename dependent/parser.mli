type token =
  | SHOWCONTEXT of (Support.info)
  | UNIV of (Support.info)
  | PI of (Support.info)
  | SIGMA of (Support.info)
  | LETREC of (Support.info)
  | FIX of (Support.info)
  | LET of (Support.info)
  | IN of (Support.info)
  | WHERE of (Support.info)
  | BOOL of (Support.info)
  | NAT of (Support.info)
  | SUCC of (Support.info)
  | PRED of (Support.info)
  | ZERO of (Support.info)
  | ISZERO of (Support.info)
  | LAMBDA of (Support.info)
  | IF of (Support.info)
  | THEN of (Support.info)
  | ELSE of (Support.info)
  | TRUE of (Support.info)
  | FALSE of (Support.info)
  | INTV of (int    Support.withinfo)
  | FLOATV of (float  Support.withinfo)
  | UCID of (string Support.withinfo)
  | LCID of (string Support.withinfo)
  | STRINGV of (string Support.withinfo)
  | APOSTROPHE of (Support.info)
  | ARROW of (Support.info)
  | DARROW of (Support.info)
  | DDARROW of (Support.info)
  | BANG of (Support.info)
  | DQUOTE of (Support.info)
  | LTBAR of (Support.info)
  | BARGT of (Support.info)
  | LCURLYBAR of (Support.info)
  | BARRCURLY of (Support.info)
  | BARRSQUARE of (Support.info)
  | LSQUAREBAR of (Support.info)
  | COMMA of (Support.info)
  | DOT of (Support.info)
  | EQ of (Support.info)
  | GT of (Support.info)
  | LT of (Support.info)
  | EQEQ of (Support.info)
  | EXISTS of (Support.info)
  | ALL of (Support.info)
  | HASH of (Support.info)
  | LCURLY of (Support.info)
  | RCURLY of (Support.info)
  | LPAREN of (Support.info)
  | RPAREN of (Support.info)
  | LSQUARE of (Support.info)
  | RSQUARE of (Support.info)
  | LEFTARROW of (Support.info)
  | COLON of (Support.info)
  | COLONCOLON of (Support.info)
  | COLONEQ of (Support.info)
  | COLONHASH of (Support.info)
  | SEMI of (Support.info)
  | DSEMI of (Support.info)
  | SLASH of (Support.info)
  | STAR of (Support.info)
  | TRIANGLE of (Support.info)
  | USCORE of (Support.info)
  | VBAR of (Support.info)
  | NEWLINE of (Support.info)
  | EOF of (Support.info)

val compiler :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Syntax.context -> (Syntax.command list * Syntax.context)
val repl :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Syntax.context -> (Syntax.command list * Syntax.context)
